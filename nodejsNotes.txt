nodejs ==>
its is an javascript run time enironmnet built on chrome's v8 javascript engine.
 why nodejs?
////EventDriven &non-blocking I/O model////
///npm is largestecosystem of open
 source libraraies in the world///

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
Creating File using NodeJS==>
const fs=require('fs')
fs.writeFileSync('notes.txt','this file was created by node.js and written by sannith.')
//1st argument is file name and second is data written in it
fs.appendFileSync('notes.txt',' lives in hyderabad. ')

///////////////////////////////////////////////////////////////////////////////////////////////////////////////

importing own Files ==>

in app.js:=>
const mul=require('./utils')
const multi=mul(5,66)
console.log(multi)

in util.js:=>
const mul= function(a,b){
    return a *b
}

module.exports= mul

////////////////////////////////////////////////////////////////////////////////////////////////////

importing NPM modules==>

npm init //creates package.json file
npm i module@version 
ex:=npm i chalk@2.4.1

in app.js:=>
const val=require('validator');
console.log(val.isURL('https/snnithresume.netlify.com'))

///////////////////////////////////////////////////////////////////////////////////////////////////////

Global Npm module and nodemon==>

npm i nodemon  -g
nodemon -v // check version to conformation downloded perfect
nodemon app.js

with this nodemon app refresh automatic ,no need to run node app.js unnecessarly

////////////////////////////////////////////////////////////////////////////////////////////////////////
FileSystem And Command line args==>

getting inputs from users==>
console.log(process.argv)
// it returns array of arguments here 1st two arg are path defined 
and from 3rd it is user defined argment


in app.js:=>
const comand=process.argv[2]
if(command==='add')
{
console.log("notes is added")
}
else if(command==='del')
{
console.log("notes is deleted")
}

in terminal:==>
node app.js add
output:notes is added
node app.js del
output:notes is deleted

node app.js  add --title="Things To Buy"
console.log(process.argv[3])
output:= --title=Things To Buy

//////////////////////////////////////////////////////////////////////////////////////////////////////

Arguments Passing with Yargs==>

npm i yargs
const  yargs=require('yargs')
console.log(yargs.argv)

node app.js  add --title="Things To Buy"
output:{_:['add'],title:'Things To Buy','$0':'app.js'}

//customize yargs version
yargs.version('1.1.0')
node app.js --version
output:=1.1.0

// Create add command
yargs.command({
    command: 'add',
    describe: 'Add a new note',
    handler:function() {
     console.log('adding a new note')
    }
})

node app.js --help
node app.js add
output:=adding a new note

// Create remove command
yargs.command({
    command: 'remove',
    describe: 'Remove a note',
    handler:function( ) {
   console.log('removing a note')
    }
})

node app.js remove
output:=removing a note

// Create list command
yargs.command({
    command: 'list',
    describe: 'List your notes',
    handler:function() {
        console.log('listing out all the notes')
    }
})

node app.js list
output:=listing out all the notes'



// Create read command
yargs.command({
    command: 'read',
    describe: 'Read a Note',
    handler:function() {
        console.log('Reading a notes')
    }
})

node app.js read
output:=Reading a notes

///////////////////////////////////////////////////////////////////////////////////////////////////////

Arguments Passing with Yargs II part==>

// Create add command
yargs.command({
    command: 'add',
    describe: 'Add a new note',
builder:{
title:{
describe:'note title',
demandOption:true,
type:'string'},
body:{
describe:'body',
demandOption:true,
type:'string'}
},
    handler:function() {
     console.log('title is='+argv.title)
console.log('body='+argv.body)

    }
})
yargs.parse( )

node app.js --help
node app.js add --title="my first title"
output:=title is=my first title
node app.js add --title="my first title" --body="this is  body of the app"
output:=title is=my first title
              body=this is  body of the app

//////////////////////////////////////////////////////////////////////////////////////////////////////////

Storing Data with Json==>

in .js file:=>
const laptop={
    brand:'dell',
    ram:'8gb',
    windows:10,
    color:'silver'
}
const laptopJS=JSON.stringify(laptop)
console.log(laptopJS)
const lap=JSON.parse(laptopJS)
console.log(lap.color)
//////////////////////////////////////////////////////////////
creating json file using node:=>

const fs=require('fs')
const laptop={
    brand:'dell',
    ram:'8gb',
    windows:10,
    color:'silver'
}
const laptopJS=JSON.stringify(laptop)
fs.writeFileSync('1-json.json',laptopJS)
/////////////////////////////////////////////////////////////////
reading json file with node:=>

const fs=require('fs')
const dataBuffer=fs.readFileSync('1-json.json')
const dataJson=dataBuffer.toString()
const lap=JSON.parse(dataJson)
console.log(lap.ram)
///////////////////////////////////////////////////////////////////
overriding the data:=>

const dataBuffer=fs.readFileSync('1-json.json')
const dataJson=dataBuffer.toString()
const user=JSON.parse(dataJson)
user.name='sannith'
user.age=24
const userJson=JSON.stringify(user)
fs.writeFileSync('1-json.json',userJson)
//////////////////////////////////////////////////////////////////
Adding Note==>

/////in app.js:=>
const Notes=require('./notes.js')
const yargs=require('yargs')

yargs.command({
    command: 'add',
    describe: 'Add a new note',
    builder:{
        title:{
            describe:'note title',
            demandOption:true,
            type:'string'


        },
         body:{
            describe:'body description',
            demandOption:true,
            type:'string'


        }
    },
    handler:function(argv) {
        Notes.addNotes(argv.title,argv.body)
   

    }
})
yargs.parse()

////in notes.js:=>

const fs=require('fs')
const getNotes= function(){
    return 'your notes'
}
const addNotes=function(title,body){
const notes=loadNotes()
notes.push({
    title:title,
    body:body
})
console.log(notes)
saveNotes(notes)
}
const saveNotes=function(notes){
    const dataJson=JSON.stringify(notes)
    fs.writeFileSync('notes.json',dataJson)

}
const loadNotes=function(){

    try{
        const bufferData=fs.readFileSync('notes.json')
    const dataJson=bufferData.toString()
    return JSON.parse(dataJson)

    }
    catch(e){
        return []

    }
    

}
module.exports={getNotes:getNotes,
addNotes:addNotes}
//////////////////////////////////////////////////////////////////////////////////////////
adding filter to add note===>

if title already it will not add notes

const addNotes=function(title,body){
const notes=loadNotes()
const duplicates=notes.filter(function(note){
    return note.title===title
})
if(duplicates.length===0)
{
    notes.push({
        title:title,
        body:body
    })
    
    saveNotes(notes)
    console.log('new note added succesfully=',notes)
    }
else{
    console.log('note title as already taken')

}
}
////////////////////////////////////////////////////////////////////////////////////
Removing Note==>

//in app.js:=>
const Notes=require('./notes.js')
const yargs=require('yargs')
yargs.command({
    command: 'remove',
    describe: 'remove a new note',
    builder:{
        title:{
            describe:'note title',
            demandOption:true,
            type:'string'


        }
    },
    
    handler:function(argv) {
        Notes.removeNotes(argv.title)
     
   

    }
})
yargs.parse()

in notes.js:=>
const removeNotes=function(title){
    const notes=loadNotes()
    const notesToKeep=notes.filter(function(note){
        return note.title!==title
    })
    if(notes.length>notesToKeep.length){
        console.log(chalk.green.inverse('note removed succesfully'))
    }
    else{
        console.log(chalk.red.inverse(' no note found'))

    }
    saveNotes(notesToKeep)
    

}
/////////////////////////////////////////////////////////////////////////////////////////////////////

 ES5 convert to ES6==>

 const square = function (x) {
     return x * x
 }

 const square = (x) => {
     return x * x
 }

 const square = (x) => x * x

console.log(square(2))

const event = {
    name: 'Birthday Party',
    guestList: ['Andrew', 'Jen', 'Mike'],
    printGuestList() {
        console.log('Guest list for ' + this.name)
        
        this.guestList.forEach((guest) => {
            console.log(guest + ' is attending ' + this.name)
        })
    }
}

event.printGuestList()

///////////////////////////////////////////////////////////////////////////////////////////////////

ListNotes==>

///in app.js:=>
const Notes=require('./notes.js')
const yargs=require('yargs')
yargs.command({
    command: 'listnotes',
    describe: 'list all notes',
    handler:function() {
        Notes.listNotes()
    }
})
yargs.parse()

///in notes.js:=>
const listNotes=()=>{
    const notes=loadNotes()
    console.log(chalk.inverse('your Notes'))
    notes.forEach((note)=>console.log(note.title))
    
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
 overcome addnotes problem==>

const addNotes=function(title,body){
const notes=loadNotes()
const duplicate=notes.find(function(note){  ///replaced filter with find
    return note.title===title
})
if(!duplicate)    ///if(duplicate.length===0)
{
    notes.push({
        title:title,
        body:body
    })
    
    saveNotes(notes)
    console.log(chalk.green.inverse('new note added succesfully='))
    }
else{
    console.log(chalk.red.inverse('note title as already taken'))

}
}
//////////////////////////////////////////////////////////////////////////////////////////////////////

ReadNotes==>

///in notes.js:=>
const readNotes=(title)=>{
    const notes=loadNotes()
    const note=notes.find((note)=>note.title===title)
    if(note){
        console.log(chalk.inverse.blue(note.title))
        console.log(chalk.green(note.body))
    }
    else{
        console.log(chalk.red.inverse('note not found'))
    }

}

///in app.js:=>
yargs.command({
    command: 'read',
    describe: 'read a new note',
    builder:{
        title:{
            describe:'note title',
            demandOption:true,
            type:'string'


        }
    },
    
    handler:function(argv) {
     notes.readNotes(argv.title)
   

    }
})
yargs.parse()
//////////////////////////////////////////////////////////////////////////////////////////////////

Asynchronus Basics==>

inapp.js:=>
console.log('start')
setTimeout(()=>{console.log('10 sec timer')},10000)
console.log('end')

output:
start
end
10 sec timer

//call stack
it is an datastructure provided by v8 javaSriptEngine
job of it was keep  tracking execution of program

const namesList=(lists)=>{
    lists.forEach((list)=>console.log(list))
}
const lists=['sannith','santhu','reddy']
namesList(lists) 
// in call stack:->
loads in order:
main()
namesList([.....])
forEach( )
anonymous('sannith')
console.log('sannith')                         output in console:
                                                             1.sannith
main()
namesList([.....])
forEach( )
anonymous('santhu') 
console.log('santhu)  
                                                             output in console:
                                                             1.sannith
                                                             2.santhu
main()
namesList([.....])
forEach( )
anonymous('reddy')
console.log('reddy')
                                                                 output in console:
                                                             1.sannith
                                                             2.santhu
                                                             3.reddy

call stack becomes empty at last
//////////////////////////////////////////////////////////////////////////////////////////////////

NodeApis & EventLoop==>

console.log('start')
setTimeout(()=>{console.log('10 sec timer')},10000)
setTimeout(()=>{console.log('0 sec timer')},0)
console.log('end')
 
in call stack:=>                                in nodeApis:=   
main()                                                    setTimeout(10 sec)
console.log()                                           setTimeout(0 sec)                                  
console.log()

in Event loop:==>
call back queue
  setTimeout(0 sec) 
  setTimeout(10 sec)  

note:=
=>when main() is completed and removed from call stack it is end of synchronous program
=>in asynchronous program after ending of main() in stack its load call back queues
into stack
ie
in call stack:=>
setTimeout(0 sec) 
  setTimeout(10 sec)  
 and final output in console :=>
1.start
2.end
3.0sec timer
4.10sec timer
///////////////////////////////////////////////////////////////////////////////////////////////////////

Https Requests==>

npm  init -y
npm i request

const req=require('request')
const url='http://api.weatherstack.com/current?access_key=6a4269392d394a7edff489df394a6bd0&query=New%20York'
req({url:url},(error,response)=>
                               {const data=JSON.parse(response.body)
                                   console.log(data)
                                 })
////////////////////////////////////////////////////////////////////////////////////////////////////////////
Customize http request==>

const req=require('request')
const url='http://api.weatherstack.com/current?access_key=6a4269392d394a7edff489df394a6bd0&query=New%20York'
req({url:url,json:true},(error,response)=>
                               {
                                   console.log(response.data)
                                 })
///2nd example
const req=require('request')
const url='https://zomatoajulypi.herokuapp.com/location'
req({url:url,json:true},(error,response)=>
                               {const data=response.body
                                   console.log('hi this restaurent is located at'+data[0].location_name+'and state that belongs to'+data[0].state)
                                 })
output:=>
hi this restaurent is located atAshok Vihar Phase 3, New Delhiand state that belongs toDelhi
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Handling Errors==>

const req=require('request')
const url='http://api.weatherstack.com/current?access_key=6a4269392d394a7edff489df394a6bd0&query=New%20York'
req({url:url,json:true},(error,response)=>
                               {
                                   if(error)
                                        {
                                          console.log('unable to connect to url')
                                          } 
                                else if(response.body.error)
                                        {
                                         console.log('unable to find location please check input arguments')
                                           }
                                   else{
                                   console.log(response.data)
                                    }
                                 })

//y example 2: geocode:=>
 
const req=require('request')
const url='geocodeurl of mapbox'
req({url:url,json:true},(error,response)=>
                               {
                                   if(error)
                                        {
                                          console.log('unable to connect to url')
                                          } 
                                else if(response.body.features.length===0)
                                        {
                                         console.log('unable to find location please check input arguments')
                                           }
                                   else{
                                   const longitude=(response.body.features[0].center[0])
                                    const latitude=(response.body.features[0].center[1])
                                    console.log (longitude,latitude)
                                    }
                                 })
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

call back function:==>

const greet=(address,callback)=>{

        const data={lat:1231,lng:5454}
        return data 
    
}
const data=greet('goodmorning')
console.log(data)

output:=>
{ lat: 1231, lng: 5454 }  //// but this synchronus method

//y
const greet=(address,callback)=>{
    setTimeout(()=>{
        const data={lat:1231,lng:5454}
        return data 
    },2000)
}
const data=greet('goodmorning')
console.log(data)

output:=>
undefiened

///to over come this call back functions comes into pitcure

const greet=(address,callback)=>{
    setTimeout(()=>{
        const data={lat:1231,lng:5454}
        callback(data) 
    },2000)
}
greet('goodmorning',(output)=>{console.log('output') })
output:=>
{lat:1231,lng:5454}


const add=(a,b,callback)=>{
    setTimeout(()=>callback(a+b),5000)
}
add(45,46,(add)=>console.log(add))
output:=>
91
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
call back absrtraction:=>>

create utils folder and init creae geocode.js file:=>

const request=require('request')
const geocode = (address, callback) => {
    const url = 'https://api.mapbox.com/geocoding/v5/mapbox.places/' + address + '.json?access_token=pk.eyJ1IjoiYW5kcmV3bWVhZDEiLCJhIjoiY2pvOG8ybW90MDFhazNxcnJ4OTYydzJlOSJ9.njY7HvaalLEVhEOIghPTlw&limit=1'

    request({ url, json: true }, (error, { body }) => {
        if (error) {
            callback('Unable to connect to location services!', undefined)
        } else if (body.features.length === 0) {
            callback('Unable to find location. Try another search.', undefined)
        } else {
            callback(undefined, {
                latitude: body.features[0].center[1],
                longitude: body.features[0].center[0],
                location: body.features[0].place_name
            })
        }
    })
}
module.exports = geocode


//in app.js:=>

const geocode = require('./utils/geocode')
geocode('New York',(error,data)=>{
console.log('ERROR  is',error)
console.log('DATA is',data)
})

output:==>
ERROR is  undefined
DATA is {
latitude:5564654,
longitude:46545,
location:'New york, 	United States'}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
call back abstraction challange with forecast as similar to geocode

in util in forecast.js=>

const request = require('request')

const forecast = (latitude, longitude, callback) => {
    const url = 'https://api.darksky.net/forecast/9d1465c6f3bb7a6c71944bdd8548d026/' + latitude + ',' + longitude

    request({ url, json: true }, (error, { body }) => {
        if (error) {
            callback('Unable to connect to weather service!', undefined)
        } else if (body.error) {
            callback('Unable to find location', undefined)
        } else {
            callback(undefined, body.daily.data[0].summary + ' It is currently ' + body.currently.temperature + ' degress out. There is a ' + body.currently.precipProbability + '% chance of rain.')
        }
    })
}

module.exports = forecast

inapp.js:=>

geocode('New York', (error,data) => {
    if (error) {
        return console.log(error)
    }

    forecast(latitude, longitude, (error, forecastData) => {
        if (error) {
            return console.log(error)
        }

        console.log(location)
        console.log(forecastData)
    })
})

output:=>

New York
Partly cloudy It is currently  39.67 degress out. There is a 0 % chance of rain
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Accesing command line arg with yargs==>

const geocode = require('./utils/geocode')
const forecast = require('./utils/forecast')

const address = process.argv[2]

if (!address) {
    console.log('Please provide an address')
} else {
    geocode(address, (error, { latitude, longitude, location }) => {
        if (error) {
            return console.log(error)
        }

        forecast(latitude, longitude, (error, forecastData) => {
            if (error) {
                return console.log(error)
            }

            console.log(location)
            console.log(forecastData)
        })
    })
}


OUTPUT:=>
in console
node app.js  "New york"
New York
Partly cloudy It is currently  39.67 degress out. There is a 0 % chance of rains
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Short Hand And Destructuring==>

const name='sannith'
const age=24
const user={
    name:name,
    age:age,
    location:'hyderabad'
}
console.log('user data is ',user)

output:=>
user data is  { name: 'sannith', age: 24, location: 'hyderabad' }

const name='sannith'
const age=24
const user={
    name,
    age,
    location:'hyderabad'
}
console.log('user data is ',user)

output:=> //same output
user data is  { name: 'sannith', age: 24, location: 'hyderabad' }

//object destructuring=>

const movie={
    hero:'prabhas',
    heroine:'anushks',
    director:'rajamouli',
    budget:100000000

}
const hero=movie.hero  ////destructure object
console.log(hero)
console.log('hero name is',movie.hero)


//ly
const {hero,heroine,director,budget}= movie
console.log('hero name is',hero)

const {hero:heroname,heroine,director,budget}= movie
console.log('hero name is',heroname)

const {hero:heroname,heroine,director,budget=500000000}= movie //updated
console.log('movie budget is',budget)


const movie={
    hero:'prabhas',
    heroine:'anushks',
    director:'rajamouli',
    budget:100000000

}


const transaction=(type,{hero,director,budget})=>{
    console.log(type,hero,director,budget)
}
transaction('industry',movie)
output:=>
industry prabhas rajamouli 100000000s
///////////////////////////////////////////////////////////////////////////////////////////////////
destructuring complete weather app:==>

in app.js:=>

const geocode = require('./utils/geocode')
const forecast = require('./utils/forecast')

const address = process.argv[2]

if (!address) {
    console.log('Please provide an address')
} else {
    geocode(address, (error, { latitude, longitude, location }) => {
        if (error) {
            return console.log(error)
        }

        forecast(latitude, longitude, (error, forecastData) => {
            if (error) {
                return console.log(error)
            }

            console.log(location)
            console.log(forecastData)
        })
    })
}

in forecast.js=>

const request = require('request')

const forecast = (latitude, longitude, callback) => {
    const url = 'https://api.darksky.net/forecast/9d1465c6f3bb7a6c71944bdd8548d026/' + latitude + ',' + longitude

    request({ url, json: true }, (error, { body }) => {
        if (error) {
            callback('Unable to connect to weather service!', undefined)
        } else if (body.error) {
            callback('Unable to find location', undefined)
        } else {
            callback(undefined, body.daily.data[0].summary + ' It is currently ' + body.currently.temperature + ' degress out. There is a ' + body.currently.precipProbability + '% chance of rain.')
        }
    })
}

module.exports = forecast

in geocode.js:=>>

const request = require('request')

const geocode = (address, callback) => {
    const url = 'https://api.mapbox.com/geocoding/v5/mapbox.places/' + address + '.json?access_token=pk.eyJ1IjoiYW5kcmV3bWVhZDEiLCJhIjoiY2pvOG8ybW90MDFhazNxcnJ4OTYydzJlOSJ9.njY7HvaalLEVhEOIghPTlw&limit=1'

    request({ url, json: true }, (error, { body }) => {
        if (error) {
            callback('Unable to connect to location services!', undefined)
        } else if (body.features.length === 0) {
            callback('Unable to find location. Try another search.', undefined)
        } else {
            callback(undefined, {
                latitude: body.features[0].center[1],
                longitude: body.features[0].center[0],
                location: body.features[0].place_name
            })
        }
    })
}

module.exports = geocodes
/////////////////////////////////////////////////////////////////////////////////////////////

Express (npm package module to create web server)===>

const express=require('express')
const app=express()
app.get('/',(req,res)=>{
    res.send('hello express!!!!!!!!!!!!!!!!')

})
app.get('/about',(req,res)=>{
    res.send('about page')

})
app.get('/help',(req,res)=>{
    res.send('help page')

})
app.get('/weather',(req,res)=>{
    res.send('waeather page')

})
app.listen(3000,()=>{
    console.log('express server listening on port 3000')
})
///////////////////////////////////////////////////////////////////////////////////////////

Serving up html and json==>

app.get('/weather',(req,res)=>{
    res.send({ forecast:'it is snowing',location:'New York'})

})

app.get('/about',(req,res)=>{
    res.send('<h1>About Page Details</h1>')

})
/////////////////////////////////////////////////////////////////////////////////////////////////////
Serving up static assets==>
in public folder in index.html:=

<html>
    <head>
        
    </head>
    <body>
        <h1>from a static file</h1>
    </body>
</html>

in app.js:=>

const path=require('path')
app.use(express.static(path.join(__dirname,'../public')))
app.listen(3000,()=>{
    console.log('express server listening on port 3000')
})
/////////////////////////////////////////////////////////////////////////////////////////

Serving up css ,js and images==>


in public create images and css folders
in css create stylesheet.css
in js create app.js file
in images folder add imagec of jpeg format

in about.html:=>
<html>
    <head>
<link rel="stylesheet" href="./css/stylesheet.css">
<script src="./js/app.js"></script>
        
    </head>
    <body>
        <h1>About in html</h1>
       <img src="./images/WhatsApp Image 2022-03-14 at 7.57.44 PM.jpeg"/>
    </body>
</html>
///////////////////////////////////////////////////////////////////////////////////////////////////////

Dynamic Pages with templating==>

handlebars package
 npm  i hbs

crate seperate folder views in that add files index.hbs,about.hbs and copy all that from public to views
in index.hbs:=>

<html>
    <head>
        
    </head>
    <body>
        <h1>{{title}}</h1>
<p>created by {{name}}<P>
    </body>
</html>



in app.js:=>
app.set('view engine','hbs')
app.get(' ',(req,res)=>
                      {res.render('index',{
                                                       title:'weather app',
                                                        name:'sannith'})
                                                           })

//y in about.hbs:=>

<html>
    <head>
        
    </head>
    <body>
        <h1>{{title}}</h1>
<img src=' '  />
<p>created by {{name}}<P>
    </body>
</html>

in app.js:=>
app.set('view engine','hbs')
app.get('/about ',(req,res)=>
                      {res.render('about',{
                                                       title:'About me',
                                                        name:'sannith'})
                                                           })
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

customizing views directory:===>

rename views folder to templates

it throws error while running

to over come this

const viewsPath=path.join(__dirname,'../templates')
app.set('views',viewsPath)

///////////////////////////////////////////////////////////////////////////////////////////////////////

Advance Templating:==>

in app.js:=>
const hbs=require('hbs')

in templates folder add two folders views and partial
in views coppy all .hbs file 

const viewsPath=path.join(__dirname,'../templates/views')
app.set('views',viewsPath)

const partialPath=path.join(__dirname,'../templates/partial')
hbs.registerPartilas(partialPath)

in partial folder add header.hbs
in that
<h1>static header .hbs text<h1>

in help.hbs

<html>
    <head>
        
    </head>
    <body>
    {{>header}}
        <h1>{{helptext}}</h1>
<p>created by {{name}}<P>
    </body>
</html>

in app.js:=>

app.get(' /help',(req,res)=>
                      {res.render('help',{
                                                       helptext:'this is text to help',
                                                        name:'sannith'})
                                                           })


//add  {{>header}}to all .hbs files

in header.hbs:=>

<h1>{{title}}<h1>
<div>
<a href='/'>weather</a>
<a href='/about'>about</a>
<a href='/help'>help</a>
</div>


//creating partilas for footer

in partial folder create footer.hbs
in that 
<p> this app is devoloped by {{name}}

////add  {{>footer}}to all .hbs files

//////////////////////////////////////////////////////////////////////////////////////////////////////////

404 pages==>

localhost:3000/sannith
cannot GET /sannith

IN app.js:=>

app.get('*',(req,res)=>{
                                       res.send('this is your 404 page')})
localhost:3000/sannith
this is your 404 page

app.get('/help/*',(req,res)=>{
                                       res.send('help text is not found')})

localhost:3000/help/text
help text is not found


in views create 404.hbs
in that

<html>
    <head>
        
    </head>
    <body>
    {{>header}}
<p>{{errormessage}}<p>
{{>footer}}
 
    </body>
</html>

in app.js:=>

app.get('*',(req,res)=>{
                                       res.render('404',{
                                                                    title:'404',
                                                                    name:'sannith',
                                                                    errormessage:'page not found'})
                                          })
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

Accesing APIS from Browser==>

Query String:=>

app.get('/products',(req,res)=>{
                                                     res.send({products:[]})
                                                      })

localhost:3000/products
{
"products":[]
}

localhost:300/products?search=watches&rating=5

app.get('/products',(req,res)=>{
                                                    console.log(req.query.search)
                                                     res.send({products:[]})
                                                      })


localhost:300/products?search=watches&rating=5
{
"products":[]
}
in console
watches

app.get('/products',(req,res)=>{
if(!req.query.search){
 return res.send(
{error:'please provide search term'})
}
 console.log(req.query.search)
 res.send({products:[]})
 })

localhost:300/products
{
"error":"please provide search term"
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////

app.get('/wether',(req,res)=>{res.send({forecast:'it is hot',location:'india'})})

localhost:3000/weather
{
"forcast":"it is hot",
"location":"india"
}

localhost:3000/weather?address=us

app.get('/wether',(req,res)=>
{
if(!req.query.address){
return res.send({error:'please provide address'})}
res.send({forecast:'it is hot',
                 location:'india',
                 adsress:req.query.address
                })
})

localhost:3000/weather?address=us
{
"forecast":"it is hot",
"location":"india",
 "address":"us"

}
//////////////////////////////////////////////////////////////////////////////////////////////////////////

Building Json Http end  point:==>>>>

copy utils folder from weather-app to web-server

npm i request in web-server


app.get('/weather', (req, res) => {
    if (!req.query.address) {
        return res.send({
            error: 'You must provide an address!'
        })
    }

    geocode(req.query.address, (error, { latitude, longitude, location } ) => {
        if (error) {
            return res.send({ error })
        }

        forecast(latitude, longitude, (error, forecastData) => {
            if (error) {
                return res.send({ error })
            }

            res.send({
                forecast: forecastData,
                location,
                address: req.query.address
            })
        })
    })
})
////////////////////////////////////////////////////////////////////////////////////////////////////////////

Default function parameter:===>

const greet=(name)=>{
console.log('hello', name)
}

greet('sannith')
output:= hello sannith

const greet=(name)=>{
console.log('hello', name)
}
greet()
hello undefined

const greet=(name='user')=>{
console.log('hello', name)
}
greet()
hello user

//destructred object cant be undefined it throws error
const laptop={
brand:'dell',
color:'silver',
ram:'8gb'}
const {brand,color,ram}=laptop
console.log(brand)
output:=
dell

const transaction=(type,{brand})=>{s
console.log(type ,brand)
}
transaction('order',laptop)
output:=>
order dell

transaction('order')
//it throws error because is is destructured object

to over come this

const transaction=(type,{brand}={})=>{
console.log(type ,brand)
}
transaction('order')
output:=>
order  undefined


localhost:3000/weather?address=!
output :=>
in console crashed
type of error:cannot desturcture property 'lattitude' of  'undefined' 
to overcomec this

 geocode(req.query.address, (error, { latitude, longitude, location } ={}) 
/////////////////////////////////////////////////////////////////////////////////////////////////////////

Creating Search Form====>

in public folder in js app.js:=>

const weatherForm = document.querySelector('form')
const search = document.querySelector('input')
const messageOne = document.querySelector('#message-1')
const messageTwo = document.querySelector('#message-2')

weatherForm.addEventListener('submit', (e) => {
    e.preventDefault()

    const location = search.value

    messageOne.textContent = 'Loading...'
    messageTwo.textContent = ''

    fetch('/weather?address=' + location).then((response) => {
        response.json().then((data) => {
            if (data.error) {
                messageOne.textContent = data.error
            } else {
                messageOne.textContent = data.location
                messageTwo.textContent = data.forecast
            }
        })
    })
})

in index.hbs:=>

<!DOCTYPE html>

<html>

<head>
    <title>Weather</title>
    <link rel="icon" href="/img/weather.png">
    <link rel="stylesheet" href="/css/styles.css">
</head>

<body>
    <div class="main-content">
        {{>header}}

        <p>Use this site to get your weather!</p>

        <form>
            <input placeholder="Location">
            <button>Search</button>
        </form>

        <p id="message-1"></p>
        <p id="message-2"></p>
    </div>

    {{>footer}}

    <script src="/js/app.js"></script>
</body>

</html>
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

MongoDB===>

download mongo db community server

/users/sanni/mongodb/bin/mongod.exe  --dbpath=/users/sanni/mongodb-data

installing database gui viewer(studio 3t) this connects with mongodb

inside triminal 

PS C:\Users\sanni\OneDrive\Desktop\node_course> /users/sanni/mongodb/bin/mongod.exe --dbpath=/users/sanni/mongodb-data
///////////////////////////////////////////////////////////////////////////////////////////////////////////

perform crud operations:=>

create:=>

insert one:=

const mongodb=require('mongodb')
const MongoClient=mongodb.MongoClient
const connectionURL='mongodb://127.0.0.1:27017'
const databaseName='task-manager'
MongoClient.connect(connectionURL,{useNewUrlParser:true},(error,client)=>{
    if(error)
    {
        console.log('unable to connect to database')
    }
const db=client.db(databaseName)
    db.collection('users').insertOne({
        name:'krish',age:20},
    (error,result)=>{
            if(error){
                  console.log('unable to insert into db')
                     }
console.log(result.ops)})


insert Many:=

const mongodb=require('mongodb')
const MongoClient=mongodb.MongoClient
const connectionURL='mongodb://127.0.0.1:27017'
const databaseName='task-manager'
MongoClient.connect(connectionURL,{useNewUrlParser:true},(error,client)=>{
    if(error)
    {
        console.log('unable to connect to database')
    }
const db=client.db(databaseName)
    db.collection('tasks').insertMany([{
        description:'complete react',completed:true},{description:'complete node',completed:false},{
            description:'get job',completed:false
        }],
    (error,database)=>{
            if(error){
                  console.log('unable to insert into db')
                     }
                     else{
console.log('result is',database.ops)
}})
    

})
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


Read operation:==>

findone:=>
const mongodb=require('mongodb')
const MongoClient=mongodb.MongoClient
const connectionURL='mongodb://127.0.0.1:27017'
const databaseName='task-manager'
MongoClient.connect(connectionURL,{useNewUrlParser:true},(error,client)=>{
    if(error)
    {
        console.log('unable to connect to database')
    }
const db=client.db(databaseName)
    db.collection('tasks').findOne({_id: new ObjectId("454674545545444")},
    (error,tasks)=>{
            if(error){
                  console.log('unable to fetch')
                     }
                    
            console.log(tasks)
})
  }  )



findMany:=>

const mongodb=require('mongodb')
const MongoClient=mongodb.MongoClient
const connectionURL='mongodb://127.0.0.1:27017'
const databaseName='task-manager'
MongoClient.connect(connectionURL,{useNewUrlParser:true},(error,client)=>{
    if(error)
    {
        console.log('unable to connect to database')
    }
const db=client.db(databaseName)
    db.collection('tasks').find({description:'complete node'}).toArray(
    (error,tasks)=>{
            if(error){
                  console.log('unable to fetch')
                     }
                    
            console.log(tasks)
})
  }  )

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Promises:=>(instead off call back it is better to use promises)
//callback
const CallBackfun=(callback)=>{
    setTimeout(()=>{
       // callback('this is error','')
       callback(undefined,[{name:'sannith',age:24},{name:'ram',age:25}])
    },2000)
}
CallBackfun((error,result)=>{
    if(error){
       return  console.log(error)
    }
    console.log(result)
})
///promise

const doWorkPromise=new Promise((resolve,reject)=>{
    setTimeout(()=>{
        resolve([4,5,6])
        //reject('somthing went wrong')
    },2000)
})

doWorkPromise.then((result)=>{
    console.log('success output',result)
}).catch((error)=>{
    console.log('error out put is',error)
})


note: only one run either in .then or .catch

in callback it runs both depends upon if else
in call back we cant(1 &2 at a time)
1.callback('this is error',undefined )
  2.callback(undefined,[{name:'sannith',age:24},{name:'ram',age:25}])
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

update One:=>

const mongodb=require('mongodb')
const {ObjectId}=require('mongodb')
const MongoClient=mongodb.MongoClient
const connectionURL='mongodb://127.0.0.1:27017'
const databaseName='task-manager'
MongoClient.connect(connectionURL,{useNewUrlParser:true},(error,client)=>{
    if(error)
    {
        console.log('unable to connect to database')
    }
    const db=client.db(databaseName)
    const updatePromise=db.collection('users').updateOne({_id:new ObjectId('632aebae7fab18fba5b3cd13')},{$set:{
        name:'krishna RAJ'
    }}
    )
    updatePromise.then((result)=>{
        console.log(result)

    }).catch((error)=>{
        console.log(error)

    })
})

//y  $inc:{
        age:10 }

UpdateMany:=>>

const mongodb=require('mongodb')
const {ObjectId}=require('mongodb')
const MongoClient=mongodb.MongoClient
const connectionURL='mongodb://127.0.0.1:27017'
const databaseName='task-manager'
MongoClient.connect(connectionURL,{useNewUrlParser:true},(error,client)=>{
    if(error)
    {
        console.log('unable to connect to database')
    }
    const db=client.db(databaseName)
    db.collection('tasks').updateMany({completed:true},{$set:{
        completed:false
    }}
    ).then((result)=>{
        console.log(result)

    }).catch((error)=>{
        console.log(error)

    })
})
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Delete:==>

deletemany:=>

 const db=client.db(databaseName)
    db.collection('tasks').deleteMany({completed:true}
    ).then((result)=>{
        console.log(result)

    }).catch((error)=>{
        console.log(error)

    })

deleteone:=>

const db=client.db(databaseName)
    db.collection('tasks').deleteOne({_id: new ObjectId('632aef80aa4f2ed04b00291c')}
    ).then((result)=>{
        console.log(result)

    }).catch((error)=>{
        console.log(error)

    })
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Setting up Mongoose:=>

in task-manager 
npm i mongoose

create src folder in task-manger 
create db folder in src
and add mongoose.js file in it

const mongoose=require('mongoose')
mongoose.connect( 'mongodb://127.0.0.1:27017/task-manager-api',{useNewUrlParser:true,useCreateIndex:true})
const user=mongoose.model('User',{
           name:{type:String },
            age:{  type:Number}
})
const me=new User({
name:'chiranjeevi',
age:60})

me.save().then((result)=>{console.log(result)}).catch((e)=>{console.log(e)})



//ly
const Tasks=mongoose.model('Tasks',{
    description:{
     type : String },
     completedstatus:{
         type : Boolean}
})
const task = new Tasks({
description:'complete node by month end ',
completedstatus:true})

task.save().then(()=>{console.log(me)}).catch((error)=>{console.log('error is',error)})
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Data validation and sanitization:====>

const User=mongoose.model('User',{
            name:{
           type : String,
             required:true,
             trim:true,
            },
           age:{
               type : Number,
                maxLength:3}
})



 age:{
               type : Number,
               default:0,
                 validate(value){
                    if(value<0)
                    throw new Error('age must be positive integer')
                 }}

inside task-manager 
npm i validator

 email:{
                type:String,
                required:true,
                trim:true,
                validate(value){
                    if(!validator.isEmail(value)){
                        throw new Error('email is invalid')
                    }
                }
             }


 password:{type:String,minLength:7,trim:true,
                validate(value)
                {if(value.toLowerCase().includes('password'))
             {throw new Error('password not should be typed as password')}
            }},


//y
task

const mongoose=require('mongoose')

mongoose.connect( 'mongodb://127.0.0.1:27017/task-manager-api',{useNewUrlParser:true})
const Tasks=mongoose.model('Tasks',{
    description:{
     type : String,required:true,trim:true },
     completedstatus:{
         type : Boolean,default:false}
})
const task = new Tasks({
description:'get job as soon as bootle', completedstatus:false
})
task.save().then(()=>{console.log(task)}).catch((error)=>{console.log('error is',error)})

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Structuring  REST API:===>>

representational state transfer- application programming inerface

Get
post

create ---> post/tasks
read----> get/tasks
read---->get/tasks/:id    //id is place holder to target individual items
update---> patch/tasks/:id
delete--->delete/tasks/:id
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Postman:===>

create new collection    collectioname:weather app
create basic request    requestname:get weather 

then select get method
paste weatherapp url  and send
then we get data 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Rest - apis and mongoose(task-app)
Resource creation Endpoints: part 1=============>>


in task-manager npm i nodemon --save-dev

npm i express
create index.js in src file

in package.json
inside scripts
 "start": "node src/index.js",
    "dev":"nodemon src/index.js"


inside index.js

const express=require('express')
const app=express()
const port=process.env.PORT || 3000

app.post('',(res,req)=>{
res.send('welcome back sannith')})

app.listen(port,()=>{
    console.log('server is upon port number'+port)
})


inside terminal:
 npm  run dev



const express=require('express')
const app=express()
const port=process.env.PORT || 3000
app.use(express.json())

app.post('/users',(req,res)=>{
    console.log('body',req.body)
res.send('welcome back sannith')
})

app.listen(port,()=>{
    console.log('server is upon port number'+port)
})



create models folders inside src 
add usermodel.js in it


const mongoose=require('mongoose')
const validator=require('validator')

const User=mongoose.model('User',{
                name:{
              type : String,
               trim:true,
                required:true },
             email:{
                    type:String,
                    required:true,
                    trim:true,
                   lowercase:true,
                   validate(value){
                     if(!validator.isEmail(value)){
                            throw new Error('email is invalid')
                      }
                   }
    
                  },
                 password:{type:String,minLength:7,trim:true,
                    required:true,
                     validate(value)
                     {if(value.toLowerCase().includes('password'))
                  {throw new Error('password not should be typed as password')}
                 }},
                age:{
                    type : Number,
                    default:0,
                    maxLength:3,
                      validate(value){
                         if(value<0)
                         throw new Error('age must be positive integer')
                     }}
     })
     module.exports=User




inside mongooese.js del all
keep only mongoose connection

then finally in index.js

const express=require('express')
const User = require('./models/usermodel')
require('./db/mongoose')
require('./models/usermodel')
const app=express()
const port=process.env.PORT || 3000
app.use(express.json())

app.post('/users',(req,res)=>{
    const user= new User(req.body)
    user.save().then(()=>res.send(user)).catch((e)=>{res.send(e)})
    //console.log('body',req.body)
//res.send('welcome back sannith')
})

app.listen(port,()=>{
    console.log('server is upon port number'+port)
})



inside postman enter raw data and see output calling correct

.catch((e)=>{
        res.status(400)// to change error status
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//y to tasks

create taskmodel.js in models

const mongoose=require('mongoose')
const Tasks=mongoose.model('Tasks',{
    description:{
     type : String,required:true,trim:true },
     completedstatus:{
         type : Boolean,default:false}
})
module.exports=Tasks

in index.js

const Tasks = require('./models/taskmodel')
app.post('/tasks',(req,res)=>{
    
   const task=new Tasks(req.body)
    task.save().then(()=>res.send(task)).catch((e)=>{
        res.status(400)
        res.send(e)
 })
})
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Resource reading Endpoints: part 1

app.get('/users',(req,res)=>{
    User.find({}).then((user)=>res.send(user)).catch((e)=>{res.sendStatus(400)
    res.send(e)})})


 app.get('/tasks',(req,res)=>{
        Tasks.find({}).then((task)=>res.send(task)).catch((e)=>{res.sendStatus(400)
        res.send(e)})})

app.get('/users/:id',(req,res)=>{
        const _id=req.params.id
        User.findById(_id).then((user)=>{
            if(!user){
                return res.status(400).send()
            }
            res.send(user)
        }).catch((e)=>{res.status(500)
        res.send(e)})
    })
//////////////////////////////////////////////////////////////////////////////////////////////
Resource reading Endpoints: part 2====>

app.get('/tasks/:id',(req,res)=>{
        const _id=req.params.id
        Tasks.findById(_id).then((task)=>{
            if(!task){
                return res.status(400).send()
            }
            res.send(task)
        }).catch((e)=>{res.status(500)
        res.send(e)})
    })
////////////////////////////////////////////////////////////////////////////////////////////////////////

Promise Chaining:==>
const add = (a, b) => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(a + b)
        }, 2000)
    })
}
add(1, 1).then((sum) => {
    console.log(sum)
    return add(sum, 4)
}).then((sum2) => {
    console.log(sum2)
}).catch((e) => {
    console.log(e)
})


create playground folder inside task-manager
peomise1.js

require('../src/db/mongoose')
const Tasks=require('../src/models/taskmodel')
Tasks.findByIdAndUpdate('632cad132a60781be0c3ab0a',{description:'fake task'}).then((user)=>{console.log(user)
return Tasks.countDocuments({description:'fake task'})
}).then((result)=>{console.log(result)}).catch((e)=>{console.log(e)})

promise2.js

require('../src/db/mongoose')
const Tasks=require('../src/models/taskmodel')
//632cad132a60781be0c3ab0a
Tasks.findByIdAndDelete('632cad132a60781be0c3ab0a').then((task)=>{console.log(task)
return Tasks.countDocuments({completedstatus:'false'})}).then((res)=>console.log(res)).catch((e)=>{console.log(e)})
///////////////////////////////////////////////////////////////////////////////////////////////////////////

Async/Await==>

const add=(a,b)=>{
    return new Promise((resolve,reject)=>{
        setTimeout(()=>{
if(a<0||b<0){
                return reject('num must be postive integer')
            }
resolve(a+b)},2000)
    })
}

const dowork=async()=>{
    const sum =await add(45,25)
const sum2=await add(sum,40)
const sum3= await add(sum2,40)
    return sum3
  

}
dowork().then((sum)=>{console.log('sum is',sum)}).catch((e)=>{console.log(e)})

///////////////////////////////////////////////////////////////////////////////////////////////////////////////

Async/Await-2==>

in task-manager
inside promise1.js

const updateAgeAndCount=async(id,age)=>{
const user= await User.findByIdAndUpdate(id,{age})
const count=await User.countDocuments({age})
return count
}

updateAgeAndCount('632ca314c3a775088c6f8cd1',16).then((res)=>{console.log(res)})
.catch((e)=>{console.log(e)})



in promise2.js

const deleteTaskAndCount= async(id)=>{
const task=await Tasks.findByIdAndDelete(id)
const count=await Tasks.countDocuments({completedstatus:false})
return count
}

deleteTaskAndCount('4545465454545').then((res)=>{console.log(res)})
.catch((e)=>{console.log(e)})

////////////////////////////////////////////////////////////////////////////////////////////////////
Integrating Async -Await:==>>


app.post('/users',async(req,res)=>{
    const user= new User(req.body)
    try{
        const users= await user.save()
        res.send(users)

    }catch(e){
        res.status(400)
        res.send(e)

    }
    // user.save().then(()=>res.send(user)).catch((e)=>{
    //     res.status(400)
    //     res.send(e)})

})

//y change for all user models


    app.get('/users/:id',async(req,res)=>{
        const _id=req.params.id
        
        try{
           
          const user= await User.findById(_id)
          if(!user){
            return res.send('no user found')
        }
        res.send(user)

        }
        catch(e){
            res.status(400)
        res.send(e)
            
        }
        
    })
/////////////////////////////////////////////////////////////////////////////////////////////
Resource updating Endpoints: part 1====>

 app.patch('/users/:id',async(req,res)=>{
        const updates=Object.keys(req.body)
        const allowedUpdates=['name','email','password','age']
        const isValidOperation=updates.every((update)=>allowedUpdates.includes(update) )
        if(!isValidOperation){
            return res.status(400).send({error:'invalid update'})
        }
        try{
        const user =await User.findByIdAndUpdate(req.params.id,req.body,{new:true,runValidators:true})
        if(!user){
            return res.status(404).send('no user id  found to update')

        }
        res.send(user)
    }
    catch(e){
        res.status(500)
            res.send(e)
    }
    })
////////////////////////////////////////////////////////////////////////////////////////////////////////
Resource updating Endpoints: part 2====>

app.patch('/tasks/:id',async(req,res)=>{
        const updates=Object.keys(req.body)
        const allowedUpdates=['description','completedstatus']
        const isValidOperation=updates.every((update)=>allowedUpdates.includes(update) )
        if(!isValidOperation){
            return res.status(400).send({error:'invalid update'})
        }
        try{
        const task =await Tasks.findByIdAndUpdate(req.params.id,req.body,{new:true,runValidators:true})
        if(!task){
            return res.status(404).send('no task id  found to update')

        }
        res.send(task)
    }
    catch(e){
        res.status(500)
            res.send(e)
    }
    })

//////////////////////////////////////////////////////////////////////////////////////////////////
Resource deleting Endpoints: part 1====>
app.delete('/users/:id',async(req,res)=>{
        try{
            const user=  await User.findByIdAndDelete(req.params.id)
            if(!user){
              return  res.status(404).send({error:'user not found please select correct id'})
            }
            res.send(user)
            
        }
        catch(e){
            res.status(400).send(e)
        }
       

    })
///////////////////////////////////////////////////////////////////////////////////////
Resource deleting Endpoints: part 2====>

app.delete('/tasks/:id',async(req,res)=>{
        try{
            const task=  await Tasks.findByIdAndDelete(req.params.id)
            if(!task){
              return  res.status(404).send({error:'tasks not found please select correct id'})
            }
            res.send(task)
            
        }
        catch(e){
            res.status(400).send(e)
        }
       

    })
    ////////////////////////////////////////////////////////////////////////////////////////////
Separate Route files==>

create routers folders inside src
add user.js and task.js

inside index.js keep only 

const express=require('express')
const userRouter=require('../src/routers/user')
const taskRouter=require('../src/routers/task')
require('./db/mongoose')
const app=express()
app.use(express.json())
app.use(userRouter)
app.use(taskRouter)
const port=process.env.PORT || 3000
app.listen(port,()=>{
    console.log('server is upon port number'+port)
})

in routers inside user.js==>

const express=require('express')
const User=require('../models/usermodel')
const router=new express.Router()
router.post('/users',async(req,res)=>{
    const user= new User(req.body)
    try{
        const users= await user.save()
        res.send(users)

    }catch(e){
        res.status(400)
        res.send(e)

    }
})
router.get('/users',async(req,res)=>{
    try{
        const user = await User.find({})
        res.send(user)

    }
    catch(e){
        res.sendStatus(400)
    res.send(e)
    }
   })
   router.get('/users/:id',async(req,res)=>{
    const _id=req.params.id
    
    try{
       
      const user= await User.findById(_id)
      if(!user){
        return res.status(400).send('no user found')
    }
    res.send(user)

    }
    catch(e){
        res.status(400)
    res.send(e)
        
    }
    
})
router.patch('/users/:id',async(req,res)=>{
    const updates=Object.keys(req.body)
    const allowedUpdates=['name','email','password','age']
    const isValidOperation=updates.every((update)=>allowedUpdates.includes(update) )
    if(!isValidOperation){
        return res.status(400).send({error:'invalid update'})
    }
    try{
    const user =await User.findByIdAndUpdate(req.params.id,req.body,{new:true,runValidators:true})
    if(!user){
        return res.status(404).send('no user id  found to update')

    }
    res.send(user)
}
catch(e){
    res.status(500)
        res.send(e)
}
})
router.delete('/users/:id',async(req,res)=>{
    try{
        const user=  await User.findByIdAndDelete(req.params.id)
        if(!user){
          return  res.status(404).send({error:'user not found please select correct id'})
        }
        res.send(user)
        
    }
    catch(e){
        res.status(400).send(e)
    }
   

})
module.exports= router

inside task.js==>

const express=require('express')
const Tasks=require('../models/taskmodel')
const router=new express.Router()
router.post('/tasks',async(req,res)=>{
    
    const task=new Tasks(req.body)
    try{
     const tasks= await task.save()
     res.send(tasks)
 
 
    }
    catch(e){
     res.status(400)
     res.send(e)
    }
    
 })
     router.get('/tasks',async(req,res)=>{
         try{
            const task= await Tasks.find({})
            res.send(task)
         }
         catch(e){
             res.sendStatus(400)
         res.send(e)
             
             
         }
        })
 router.get('/tasks/:id',async(req,res)=>{
         const _id=req.params.id
         try{
            task= await Tasks.findById(_id)
            if(!task){
             return res.status(400).send('no tasks found')
         }
         res.send(task)
 
         }
         catch(e){res.status(500)
             res.send(e)}
         
     })
   
 
     router.patch('/tasks/:id',async(req,res)=>{
         const updates=Object.keys(req.body)
         const allowedUpdates=['description','completedstatus']
         const isValidOperation=updates.every((update)=>allowedUpdates.includes(update) )
         if(!isValidOperation){
             return res.status(400).send({error:'invalid update'})
         }
         try{
         const task =await Tasks.findByIdAndUpdate(req.params.id,req.body,{new:true,runValidators:true})
         if(!task){
             return res.status(404).send('no task id  found to update')
 
         }
         res.send(task)
     }
     catch(e){
         res.status(500)
             res.send(e)
     }
     })
     router.delete('/tasks/:id',async(req,res)=>{
         try{
             const task=  await Tasks.findByIdAndDelete(req.params.id)
             if(!task){
               return  res.status(404).send({error:'tasks not found please select correct id'})
             }
             res.send(task)
             
         }
         catch(e){
             res.status(400).send(e)
         }
        
 
     })

     module.exports=router
////////////////////////////////////////////////////////////////////////////////////////////////////////

Securly storing password===>

npm i bcrytjs
const bcrypt=require('bcryptjs')
const myfunction=async()=>{
    const password='sannith@123456'
    const hashedpassword=await bcrypt.hash(password,8)
    console.log(hashedpassword)
    console.log(password)
 const isMatch=await bcrypt.compare(password,hashedPassword)
    console.log(isMatch)
}
myfunction()

output::=
$2a$08$c3/Wa60BvBkWrhWEnBCyCenosaMvb/0JQWYVFJMJc887TGWZ3lsum
sannith@123456
true


in user model change

const userSchema= new mongoose.Schema({
   name:{
 type : String,
  trim:true,
   required:true },
email:{
       type:String,
       required:true,
       trim:true,
      lowercase:true,
      validate(value){
        if(!validator.isEmail(value)){
               throw new Error('email is invalid')
         }
      }

     },
    password:{type:String,minLength:7,trim:true,
       required:true,
        validate(value)
        {if(value.toLowerCase().includes('password'))
     {throw new Error('password not should be typed as password')}
    }},
   age:{
       type : Number,
       default:0,
       maxLength:3,
         validate(value){
            if(value<0)
            throw new Error('age must be positive integer')
        }}
})
userSchema.pre('save',async function (next){
   const user=this
   console.log('before saving')
   next()

}
)

const User=mongoose.model('User',userSchema)
     module.exports=User
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
to get before changing update  make changes in patch url

router.patch('/users/:id',async(req,res)=>{
    const updates=Object.keys(req.body)
    const allowedUpdates=['name','email','password','age']
    const isValidOperation=updates.every((update)=>allowedUpdates.includes(update) )
    if(!isValidOperation){
        return res.status(400).send({error:'invalid update'})
    }
    try{
        const user =await User.findByIdAndUpdate(req.params.id)
        updates.forEach((update)=>{user[update]=req.body[update]})
        await user.save()
    //const user =await User.findByIdAndUpdate(req.params.id,req.body,{new:true,runValidators:true})
    if(!user){
        return res.status(404).send('no user id  found to update')

    }
    res.send(user)
}
catch(e){
    res.status(500)
        res.send(e)
}
})
//////////////////////////////////////////////////////////////////////////////////////////////////////////
in user model  
to save password as hashcode

userSchema.pre('save',async function (next){
   const user=this
   if(user.isModified('password')){
      user.password= await bcrypt.hash(user.password,8)
   }
   console.log('before saving')
   next()

}
)
////////////////////////////////////////////////////////////////////////////////////////////////
try{
            const task =await Tasks.findByIdAndUpdate(req.params.id)
             updates.forEach((update)=>{task[update]=req.body[update]})
            await task.save()
         //const task =await Tasks.findByIdAndUpdate(req.params.id,req.body,{new:true,runValidators:true})
///////////////////////////////////////////////////////////////////////////////////////////////////

logging in users====>

in router user.js=>

router.post('/users/login', async (req, res) => {
    try {
        const user = await User.findByCredentials(req.body.email, req.body.password)
        res.send( user)
    } catch (e) {
        res.status(400).send('some thing went wrong please enter valid email or password')
    }
})

in models user.js=>

userSchema.statics.findByCredentials = async (email, password) => {
   const user = await User.findOne({ email })

   if (!user) {
       throw new Error('Unable to login')
   }

   const isMatch = await bcrypt.compare(password, user.password)

   if (!isMatch) {
       throw new Error('Unable to login')
   }

   return user
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////

Json web-token:====>










































	













 







































































































